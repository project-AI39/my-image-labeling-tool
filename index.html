<!--

Labeling Tool (純粋バニラ HTML CSS JavaScript)

このファイルは、画像に対するスコア／ラベル付けを行う
シンプルなラベリングツールのフロントエンドです。

主な機能:
- ローカルフォルダ内の画像（.jpg/.jpeg/.png/.webp）を読み込み、
    画像ごとに定義済みのラベルセットで評価を行います。
- ラベル定義は JSON（ラベルルール）として読み込み可能で、
    設定に応じて各画像のラベル結果をローカルに保存します。
- ブラウザの File System Access API を利用して
    入力フォルダ／出力フォルダの選択やファイルの読み書きを行います。
- ズーム・パン・自動次画像移動・未ラベル非表示・上書き制御などの操作を提供します。
- 外部で編集された JSON をポーリングして自動更新する機能を持ちます。

想定されるワークフロー:
1) 画面上でラベル定義 JSON をアップロード、またはサンプルをコピー。
2) 入力フォルダ（画像が置かれたフォルダ）と出力フォルダを選択。
3) 「Start」して一覧から画像を評価。

注意:
- このページはローカルブラウザで動作する前提です。File System Access API は
    一部のブラウザ（Chromium 系）でのみ利用可能です。
- 大量のファイルを扱う場合、ブラウザの権限や性能に依存します。

-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labeling Tool (Pure Vanilla)</title>
    <style>
        /* --- CSS Variables (Theme Colors) --- */
        :root {
            --bg-dark: #111827;
            /* gray-900 */
            --bg-panel: #1f2937;
            /* gray-800 */
            --bg-hover: #374151;
            /* gray-700 */
            --text-main: #f9fafb;
            /* gray-50 */
            --text-sub: #9ca3af;
            /* gray-400 */
            --border: #374151;
            /* gray-700 */

            --primary: #2563eb;
            /* blue-600 */
            --primary-hover: #1d4ed8;
            --success: #10b981;
            /* emerald-500 */
            --danger: #ef4444;
            /* red-500 */
            --warning: #f59e0b;
            /* amber-500 */
        }

        /* --- Reset & Base --- */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            width: 100vw;
            overflow: hidden;

            /* Disable Text Selection */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Allow selection for text elements */
        .selectable,
        .lp-infobar,
        .error-box,
        .row-name,
        .setup-card h1,
        .setup-card h2,
        .setup-card p,
        .setup-card .subtitle,
        .sample-code {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
            cursor: auto;
        }

        /* --- Tooltip Styles --- */
        .tooltip {
            position: fixed;
            z-index: 9999;
            background: #0f172a;
            color: #f9fafb;
            padding: 8px 12px;
            border: 1px solid #374151;
            border-radius: 6px;
            font-size: 12px;
            line-height: 1.5;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s ease;
            white-space: pre-wrap;
            max-width: 300px;
            visibility: hidden;
        }

        .tooltip--visible {
            opacity: 1;
            visibility: visible;
        }

        .has-tooltip {
            cursor: help !important;
            border-bottom: 1px dotted #6b7280;
        }

        /* --- Scrollbar --- */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }

        /* --- Utilities --- */
        .hidden {
            display: none !important;
        }

        .flex {
            display: flex;
        }

        .flex-col {
            flex-direction: column;
        }

        .items-center {
            align-items: center;
        }

        .justify-center {
            justify-content: center;
        }

        .justify-between {
            justify-content: space-between;
        }

        .gap-2 {
            gap: 0.5rem;
        }

        .gap-1 {
            gap: 0.25rem;
        }

        .w-full {
            width: 100%;
        }

        .h-full {
            height: 100%;
        }

        .text-center {
            text-align: center;
        }

        /* --- App Container --- */
        #app {
            width: 100%;
            height: 100%;
        }

        /* --- Initial Screen Styles --- */
        .setup-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 20px;
            overflow-y: auto;
        }

        .setup-card {
            background-color: var(--bg-panel);
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
            max-width: 900px;
            width: 100%;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
            text-align: left;
        }

        @media(min-width: 768px) {
            .grid-2 {
                grid-template-columns: 1fr 1fr;
            }
        }

        h1 {
            font-size: 1.875rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        h2 {
            font-size: 1.125rem;
            font-weight: bold;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
        }

        p.subtitle {
            color: var(--text-sub);
            margin-bottom: 2rem;
            font-size: 0.875rem;
        }

        /* File Input Buttons */
        .file-btn {
            width: 100%;
            padding: 1rem;
            height: 6rem;
            border: 2px dashed #4b5563;
            border-radius: 0.5rem;
            background: transparent;
            color: var(--text-sub);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-bottom: 1rem;
        }

        .file-btn:hover {
            border-color: var(--primary);
            background-color: rgba(55, 65, 81, 0.5);
        }

        .file-btn.done {
            border-color: var(--success);
            background-color: rgba(6, 78, 59, 0.3);
        }

        .file-btn span.label {
            font-weight: bold;
            font-size: 0.95rem;
            color: #d1d5db;
            margin-bottom: 0.25rem;
        }

        .file-btn span.sub {
            font-size: 0.75rem;
            color: #9ca3af;
        }

        .file-btn.done span.label {
            color: #34d399;
        }

        /* Sample Config Area */
        details.sample-details {
            margin-bottom: 1rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 0.5rem;
            border: 1px solid var(--border);
            overflow: hidden;
        }

        details.sample-details summary {
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9rem;
            color: var(--primary);
            user-select: none;
            outline: none;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: background 0.2s;
        }

        details.sample-details summary:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        details.sample-details[open] summary {
            border-bottom: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        .sample-content {
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
        }

        .sample-code {
            display: block;
            background: #111827;
            padding: 1rem;
            border-radius: 0.5rem;
            font-family: monospace;
            font-size: 0.75rem;
            color: #d1d5db;
            overflow-x: auto;
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 1rem;
            white-space: pre;
            border: 1px solid #374151;
        }

        .sample-actions {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
        }

        .sm-btn {
            padding: 0.4rem 0.8rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: bold;
            cursor: pointer;
            border: 1px solid var(--border);
            background: var(--bg-hover);
            color: var(--text-main);
            transition: all 0.2s;
        }

        .sm-btn:hover {
            background: #4b5563;
            border-color: #9ca3af;
        }

        /* Settings Panel */
        .settings-panel {
            background-color: rgba(55, 65, 81, 0.3);
            padding: 1.5rem;
            border-radius: 0.5rem;
        }

        /* Toggle Switch */
        .toggle-wrapper {
            display: flex;
            justify-content: space-between;
            cursor: pointer;
            margin-bottom: 1.5rem;
        }

        .toggle-text div:first-child {
            font-weight: bold;
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
        }

        .toggle-text div:last-child {
            font-size: 0.75rem;
            color: var(--text-sub);
        }

        .toggle-switch {
            position: relative;
            width: 40px;
            height: 24px;
            background: #4b5563;
            border-radius: 24px;
            flex-shrink: 0;
            margin-left: 1rem;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
        }

        .toggle-wrapper.active .toggle-switch {
            background: var(--primary);
        }

        .toggle-wrapper.active .toggle-switch::after {
            transform: translateX(16px);
        }

        /* Range Slider */
        .range-wrapper {
            margin-bottom: 1rem;
        }

        .range-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.875rem;
            color: var(--text-sub);
            margin-bottom: 0.5rem;
        }

        .range-val {
            color: white;
            font-weight: bold;
            font-family: monospace;
        }

        input[type=range] {
            appearance: none;
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: #4b5563;
            border-radius: 3px;
            outline: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
        }

        /* Start Button */
        .start-btn {
            width: 100%;
            padding: 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            background-color: var(--primary);
            color: white;
        }

        .start-btn:disabled {
            background-color: #374151;
            color: #6b7280;
            cursor: not-allowed;
        }

        .start-btn:not(:disabled):hover {
            background-color: var(--primary-hover);
        }

        /* Error Box */
        .error-box {
            background-color: rgba(127, 29, 29, 0.5);
            border: 1px solid #b91c1c;
            color: #fecaca;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #374151;
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* --- Labeling View Styles --- */
        #labeling-view {
            display: flex;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        /* Left Panel (Image) */
        .left-panel {
            background-color: black;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border);
            position: relative;
        }

        .lp-header {
            height: 56px;
            background-color: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 12px;
            flex-shrink: 0;
            z-index: 10;
        }

        .icon-btn {
            background: transparent;
            border: none;
            color: #d1d5db;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-btn:hover {
            background-color: var(--bg-hover);
            color: white;
        }

        .icon-btn:disabled {
            opacity: 0.3;
            cursor: default;
        }

        /* Controls Area */
        .lp-controls {
            padding: 8px 12px;
            background-color: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            flex-shrink: 0;
            z-index: 10;
            overflow-x: auto;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 4px;
            flex-shrink: 0;
        }

        /* Toolbar Buttons */
        .tool-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #d1d5db;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            white-space: nowrap;
        }

        .tool-btn:hover {
            background-color: var(--bg-hover);
        }

        .tool-btn.active {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .tool-btn.active-green {
            background-color: var(--success);
            color: white;
            border-color: var(--success);
        }

        .tool-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Delete Button specific */
        .tool-btn.delete-btn {
            color: #fca5a5;
            border-color: rgba(239, 68, 68, 0.3);
            background: rgba(239, 68, 68, 0.1);
        }

        .tool-btn.delete-btn:hover:not(:disabled) {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.5);
            color: #fecaca;
        }

        .zoom-btn {
            background: var(--bg-hover);
            border: none;
            color: #d1d5db;
            padding: 6px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            background-color: #4b5563;
            color: white;
        }

        .zoom-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Filename Bar */
        .lp-infobar {
            background-color: #111827;
            border-bottom: 1px solid var(--border);
            padding: 4px 12px;
            font-size: 0.75rem;
            color: #9ca3af;
            font-family: monospace;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: center;
            flex-shrink: 0;
            z-index: 10;
        }

        .lp-infobar span.dim {
            opacity: 0.6;
        }

        .image-viewer {
            flex: 1;
            overflow: hidden;
            position: relative;
            cursor: move;
            width: 100%;
            height: 100%;
        }

        .image-viewer:active {
            cursor: grabbing;
        }

        #pan-zoom-target {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            transform-origin: center;
            will-change: transform;
        }

        #pan-zoom-target img {
            max-width: none;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            pointer-events: none;
        }

        /* Right Panel (List) */
        .right-panel {
            flex: 1;
            background-color: #ffffff;
            color: #1f2937;
            display: flex;
            flex-direction: column;
            min-width: 0;
            z-index: 20;
            height: 100%;
            box-shadow: -4px 0 15px rgba(0, 0, 0, 0.1);
        }

        .list-container {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .label-row {
            display: flex;
            border-bottom: 1px solid #e5e7eb;
            width: 100%;
            flex: 1;
        }

        .label-row.disabled {
            opacity: 0.5;
            pointer-events: none;
            background-color: #f9fafb;
            filter: grayscale(100%);
        }

        .row-name {
            width: 180px;
            background-color: #f3f4f6;
            padding: 0 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Center text vertically */
            border-right: 1px solid #d1d5db;
            flex-shrink: 0;
            font-weight: bold;
            font-size: 0.95rem;
            /* Will be adjusted by JS */
            line-height: 1.2;
            word-break: break-word;
            /* Allow wrapping */
            text-align: center;
            /* Center align text */
            overflow: hidden;
            /* Ensure overflow is hidden */
        }

        .row-idx {
            color: #9ca3af;
            font-size: 0.75rem;
            font-family: monospace;
            margin-right: 0.5rem;
            width: 1.5em;
            text-align: right;
            flex-shrink: 0;
            /* Prevent shrinking */
        }

        .row-name-text {
            /* Wrapper for the label name to allow sizing */
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
        }

        .row-clear {
            width: 80px;
            border-right: 1px solid #d1d5db;
            flex-shrink: 0;
            background-color: #f9fafb;
        }

        .row-options {
            flex: 1;
            display: flex;
            min-width: 0;
        }

        .option-btn {
            flex: 1;
            border: none;
            background: transparent;
            cursor: pointer;
            border-right: 1px solid #f3f4f6;
            color: #4b5563;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 4px;
            overflow: hidden;
            /* Ensure overflow is hidden */
        }

        .option-btn:hover {
            background-color: #f9fafb;
        }

        .option-btn.selected {
            background-color: #eff6ff;
            color: #1d4ed8;
            z-index: 1;
        }

        .option-btn.selected::after {
            content: '';
            position: absolute;
            inset: 0;
            border: 4px solid #2563eb;
            pointer-events: none;
        }

        .option-btn .opt-text {
            font-weight: bold;
            line-height: 1.2;
            /* Better line height */
            word-break: break-word;
            /* Enable wrapping */
            width: auto;
            text-align: center;
        }

        .option-btn:disabled {
            cursor: not-allowed;
            /* Keep color visible but indicate unclickable */
            opacity: 0.9;
        }
        
        .option-btn:disabled:not(.selected) {
            opacity: 0.5;
        }

        /* Clear Button specific */
        .clear-btn {
            width: 100%;
            height: 100%;
            border: none;
            background: transparent;
            color: #6b7280;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .clear-btn:hover:not(:disabled) {
            background-color: #e5e7eb;
            color: #374151;
        }

        .clear-btn.active {
            color: #1d4ed8;
            background-color: #eff6ff;
            position: relative;
        }

        .clear-btn.active::after {
            content: '';
            position: absolute;
            inset: 0;
            border: 4px solid #2563eb;
        }

        .clear-btn:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .clear-btn:disabled.active {
            opacity: 0.9;
        }

        /* Auto fit class */
        .auto-fit-text {
            max-width: 100%;
            /* Removed white-space: nowrap to allow wrapping */
            display: inline-block;
            width: auto;
        }
    </style>
</head>

<body>

    <div id="app"></div>
    <!-- Tooltip Element -->
    <div id="global-tooltip" class="tooltip" role="tooltip"></div>
    <!-- Loading Element -->
    <div id="loading-overlay" class="loading-overlay hidden">
        <div class="loading-spinner"></div>
        <div id="loading-text" style="font-size: 1.1rem; font-weight: bold;">Loading...</div>
        <div id="loading-sub" style="font-size: 0.9rem; color: #9ca3af; margin-top: 0.5rem;"></div>
    </div>

    <script>
        // ==========================================
        // 0. Icons (SVG Definitions)
        // ==========================================
        const ICONS = {
            'home': '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>',
            'prev': '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"/></svg>',
            'next': '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"/></svg>',
            'zoom-in': '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg>',
            'zoom-out': '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></svg>',
            'maximize': '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>',
            'chevron-right': '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"/></svg>',
            'trash': '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg>',
            'check-circle': '<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>',
            'refresh': '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M3 21v-5h5"/></svg>'
        };

        function getIcon(name) {
            return ICONS[name] || '';
        }

        // ==========================================
        // 1. Data & State
        // ==========================================
        const SAMPLE_CONFIG = {
            "labels": [
                {
                    "label_id": "is_valid",
                    "label_name": "Is Valid",
                    "description": "Determine if this image should be evaluated.",
                    "end_flag_value": 0,
                    "options": [
                        { "option_name": "Ignore", "option_value": 0.0, "description": "Blurry, black screen, test image, etc." },
                        { "option_name": "Valid", "option_value": 1.0, "description": "Illustration, photo, screenshot, etc." }
                    ]
                },
                {
                    "label_id": "interest",
                    "label_name": "Interest",
                    "description": "Subjective interest level. How much you want to look at it.",
                    "end_flag_value": null,
                    "options": [
                        { "option_name": "Skip", "option_value": 0.0, "description": "I see it, but I don't feel like looking at details." },
                        { "option_name": "Curious", "option_value": 0.5, "description": "I look at it once, maybe zoom in a bit." },
                        { "option_name": "Watch", "option_value": 1.0, "description": "I like the composition/theme and want to watch closely." }
                    ]
                },
                {
                    "label_id": "preference",
                    "label_name": "Preference",
                    "description": "Preference level. Do you want to save or share it?",
                    "end_flag_value": null,
                    "options": [
                        { "option_name": "Low", "option_value": 0.0, "description": "Not bad, but not my taste. Won't save." },
                        { "option_name": "Mid", "option_value": 0.5, "description": "Might look back sometimes, but not necessarily save." },
                        { "option_name": "High", "option_value": 1.0, "description": "I want to save it as wallpaper or reference." }
                    ]
                },
                {
                    "label_id": "brightness",
                    "label_name": "Brightness",
                    "description": "Overall brightness impression.",
                    "end_flag_value": 0.0,
                    "options": [
                        { "option_name": "Dark", "option_value": 0.0, "description": "Overall dark, strong shadows." },
                        { "option_name": "Normal", "option_value": 0.5, "description": "Balanced brightness." },
                        { "option_name": "Bright", "option_value": 1.0, "description": "Overall bright, strong highlights." }
                    ]
                },
                {
                    "label_id": "colorfulness",
                    "label_name": "Colorfulness",
                    "description": "Vividness and colorfulness of the image.",
                    "end_flag_value": null,
                    "options": [
                        { "option_name": "Mono", "option_value": 0.0, "description": "Black & white or limited colors." },
                        { "option_name": "Calm", "option_value": 0.33, "description": "Low saturation, quiet impression." },
                        { "option_name": "Colorful", "option_value": 0.66, "description": "Multiple colors, not too flashy." },
                        { "option_name": "Vivid", "option_value": 1.0, "description": "High saturation, very colorful." }
                    ]
                },
                {
                    "label_id": "has_people",
                    "label_name": "Has People",
                    "description": "Does the image contain humans or human-like characters?",
                    "end_flag_value": 0.0,
                    "mask_option": {
                        "option_name": "Unsure",
                        "option_value": null,
                        "description": "Silhouette only, too far away to tell."
                    },
                    "options": [
                        { "option_name": "None", "option_value": 0.0, "description": "Scenery, objects, UI only." },
                        { "option_name": "Yes", "option_value": 1.0, "description": "One or more humans/characters depicted." }
                    ]
                },
                {
                    "label_id": "scene_type",
                    "label_name": "Scene Type",
                    "description": "Main subject of the scene.",
                    "end_flag_value": null,
                    "options": [
                        { "option_name": "Scenery", "option_value": 0.0, "description": "Nature, city, interior where env is main." },
                        { "option_name": "Character", "option_value": 0.33, "description": "Character is the main subject." },
                        { "option_name": "Object", "option_value": 0.66, "description": "Product, tool, item." },
                        { "option_name": "UI/Info", "option_value": 1.0, "description": "Graph, chart, app UI, code." }
                    ]
                },
                {
                    "label_id": "complexity",
                    "label_name": "Complexity",
                    "description": "Amount of elements or information in the screen.",
                    "end_flag_value": 1.0,
                    "mask_option": {
                        "option_name": "Unsure",
                        "option_value": null,
                        "description": "Too blurry to judge details."
                    },
                    "options": [
                        { "option_name": "Very Low", "option_value": 0.0, "description": "Single object, very simple." },
                        { "option_name": "Low", "option_value": 0.25, "description": "Some elements, but clean." },
                        { "option_name": "Medium", "option_value": 0.5, "description": "Multiple objects or text, moderate info." },
                        { "option_name": "High", "option_value": 0.75, "description": "Many objects, slightly cluttered." },
                        { "option_name": "Very High", "option_value": 1.0, "description": "Dense details, many small texts." }
                    ]
                }
            ]
        };

        const state = {
            view: 'initial',
            labelConfig: null,
            inputDirHandle: null,
            outputDirHandle: null,
            fileList: [],
            currentLabels: {},
            currentIndex: 0,
            hideLabeled: false,
            autoNext: false,
            isSkipping: false,
            isSaving: false,
            pendingSaveFile: null,
            allowOverwrite: true,
            randomOrder: false,
            scale: 1,
            position: { x: 0, y: 0 },
            isDragging: false,
            dragStart: { x: 0, y: 0 },
            rowMinHeight: 40,
            imageAreaRatio: 25,
            errorMsg: '',
            statusMsg: '',
            fontSizeCache: {},
            hasExistingJson: false // Track if current file has existing labels on disk
        };

        const app = document.getElementById('app');
        const tooltipEl = document.getElementById('global-tooltip');
        const loaderEl = document.getElementById('loading-overlay');
        const loaderText = document.getElementById('loading-text');
        const loaderSub = document.getElementById('loading-sub');

        let hoverTimer = null;
        let resizeTimer = null;
        const SUPPORTED_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.webp'];

        // ==========================================
        // 2. Rendering
        // ==========================================
        function render() {
            if (state.view === 'initial') {
                renderInitialScreen();
            } else {
                if (!document.getElementById('labeling-view')) {
                    app.innerHTML = '';
                    createLabelingLayout();
                }
                updateLabelingView();
            }
        }

        function showLoader(show, mainMsg = 'Loading...', subMsg = '') {
            if (show) {
                loaderText.textContent = mainMsg;
                loaderSub.textContent = subMsg;
                loaderEl.classList.remove('hidden');
            } else {
                loaderEl.classList.add('hidden');
            }
        }

        // --- Initial Screen ---
        function renderInitialScreen() {
            app.innerHTML = '';
            const container = document.createElement('div');
            container.className = "setup-container";

            const card = document.createElement('div');
            card.className = "setup-card";

            card.innerHTML = `
            <div class="text-center">
                <h1>Image Labeling Tool (Pure Vanilla HTML CSS JavaScript)</h1>
                <p class="subtitle">Recommended: Chrome / Edge (Uses File System Access API)</p>
            </div>
        `;

            const grid = document.createElement('div');
            grid.className = "grid-2";

            // Left Col
            const leftCol = document.createElement('div');
            leftCol.innerHTML = `<h2>1. Data Source</h2>`;

            // Sample Config Area
            const sampleArea = document.createElement('details');
            sampleArea.className = 'sample-details';
            sampleArea.innerHTML = `
            <summary>
                ${getIcon('chevron-right')} 
                <span>Need a sample config?</span>
            </summary>
            <div class="sample-content">
                <p style="color:#9ca3af; font-size:0.8rem; margin-bottom:8px;">You can copy this JSON to create your own config file.</p>
                <code class="sample-code">${JSON.stringify(SAMPLE_CONFIG, null, 2)}</code>
                <div class="sample-actions">
                    <button class="sm-btn" onclick="copySample()">Copy to Clipboard</button>
                    <button class="sm-btn" onclick="downloadSample()">Download .json</button>
                </div>
            </div>
        `;
            leftCol.appendChild(sampleArea);

            leftCol.appendChild(createUploadArea(
                'Config File (.json)', 'Label Definitions', '.json',
                !!state.labelConfig,
                'Config Loaded',
                state.labelConfig ? `${state.labelConfig.length} items` : '',
                handleJsonUpload
            ));

            leftCol.appendChild(createFsButton(
                'Select Image Folder',
                !!state.inputDirHandle,
                state.inputDirHandle ? state.inputDirHandle.name : '',
                selectInputDir
            ));

            leftCol.appendChild(createFsButton(
                'Select Output Folder',
                !!state.outputDirHandle,
                state.outputDirHandle ? state.outputDirHandle.name : '',
                selectOutputDir
            ));

            // Right Col
            const rightCol = document.createElement('div');
            rightCol.innerHTML = `<h2>2. Options</h2>`;

            const settingsPanel = document.createElement('div');
            settingsPanel.className = "settings-panel";

            settingsPanel.appendChild(createToggle(
                'Allow Overwrite JSON',
                'Overwrite existing JSON files on save',
                state.allowOverwrite,
                (v) => { state.allowOverwrite = v; }
            ));

            settingsPanel.appendChild(createToggle(
                'Randomize Image Order',
                'Shuffle images instead of filename order',
                state.randomOrder,
                (v) => { state.randomOrder = v; }
            ));

            // View Settings
            const viewSettings = document.createElement('div');
            viewSettings.style.marginTop = "1.5rem";

            // Row Height Slider
            viewSettings.appendChild(createRange(
                'rowMinHeight',
                'Min Row Height', state.rowMinHeight, 30, 150, 'px',
                (v) => updateSetting('rowMinHeight', v)
            ));

            // Image Ratio Slider
            viewSettings.appendChild(createRange(
                'imageAreaRatio',
                'Image Area Width', state.imageAreaRatio, 10, 50, '%',
                (v) => updateSetting('imageAreaRatio', v)
            ));

            settingsPanel.appendChild(viewSettings);
            rightCol.appendChild(settingsPanel);

            grid.appendChild(leftCol);
            grid.appendChild(rightCol);
            card.appendChild(grid);

            // Error Msg
            if (state.errorMsg) {
                const err = document.createElement('div');
                err.className = "error-box";
                err.innerHTML = `<span>${state.errorMsg}</span>`;
                card.appendChild(err);
            }

            // Start Btn
            const startBtn = document.createElement('button');
            const isReady = state.labelConfig && state.inputDirHandle && state.outputDirHandle;
            startBtn.disabled = !isReady;
            startBtn.className = 'start-btn';
            startBtn.innerHTML = `Start Labeling`;
            startBtn.onclick = startApp;
            card.appendChild(startBtn);

            container.appendChild(card);
            app.appendChild(container);
        }

        // --- Helper Components ---
        function createUploadArea(title, sub, accept, isDone, doneMsg, doneSub, handler) {
            const div = document.createElement('div');
            div.className = `file-btn ${isDone ? 'done' : ''}`;
            div.innerHTML = `<span class="label">${isDone ? doneMsg : title}</span><span class="sub">${isDone ? doneSub : sub}</span><input type="file" accept="${accept}" class="hidden" />`;
            const input = div.querySelector('input');
            input.onchange = handler;
            div.onclick = () => input.click();
            return div;
        }

        function createFsButton(label, isSet, pathName, onClick) {
            const btn = document.createElement('button');
            btn.className = `file-btn ${isSet ? 'done' : ''}`;
            btn.onclick = onClick;
            btn.innerHTML = `<span class="label">${isSet ? 'Selected' : label}</span><span class="sub">${isSet ? pathName : 'Click to select folder'}</span>`;
            return btn;
        }

        function createToggle(label, desc, checked, onChange) {
            const wrapper = document.createElement('div');
            wrapper.className = `toggle-wrapper ${checked ? 'active' : ''}`;
            wrapper.innerHTML = `<div class="toggle-text"><div>${label}</div><div>${desc}</div></div><div class="toggle-switch"></div>`;
            wrapper.onclick = () => { onChange(!checked); render(); };
            return wrapper;
        }

        function createRange(key, label, val, min, max, unit, onChange) {
            const div = document.createElement('div');
            div.className = 'range-wrapper';
            div.innerHTML = `<div class="range-header"><span>${label}</span><span id="val-${key}" class="range-val" data-unit="${unit}">${val}${unit}</span></div><input type="range" min="${min}" max="${max}" value="${val}">`;
            div.querySelector('input').oninput = (e) => onChange(e.target.value);
            return div;
        }

        // --- Labeling View (Layout) ---
        function createLabelingLayout() {
            const container = document.createElement('div');
            container.id = 'labeling-view';

            // Left Panel
            const leftPanel = document.createElement('div');
            leftPanel.className = 'left-panel';
            leftPanel.id = 'left-panel';
            leftPanel.style.width = `${state.imageAreaRatio}%`;

            // Header (Nav)
            const header = document.createElement('div');
            header.className = 'lp-header';
            header.innerHTML = `
            <div class="flex items-center gap-2">
                <button onclick="goHome()" class="icon-btn" title="Home">${getIcon('home')}</button>
                <button onclick="reloadAll()" class="icon-btn" title="Reload List & Status">${getIcon('refresh')}</button>
            </div>
            <div class="flex items-center">
                <button id="btn-prev" onclick="changeImage(-1)" class="icon-btn">${getIcon('prev')}</button>
                <span id="page-indicator" style="margin: 0 12px; font-family: monospace; font-weight: bold;"></span>
                <button id="btn-next" onclick="changeImage(1)" class="icon-btn">${getIcon('next')}</button>
            </div>
            <div id="status-display" style="font-family: monospace; font-size: 0.8rem;"></div>
        `;
            leftPanel.appendChild(header);

            // Toolbar
            const toolbar = document.createElement('div');
            toolbar.className = 'lp-controls';
            toolbar.innerHTML = `
            <div class="control-group">
                <button id="btn-hide-labeled" onclick="toggleHideLabeled()" class="tool-btn">Hide Labeled</button>
                <button id="btn-auto-next" onclick="toggleAutoNext()" class="tool-btn">Auto Next</button>
                <button id="btn-delete-json" onclick="deleteCurrentJson()" class="tool-btn delete-btn"><span style="width:16px">${getIcon('trash')}</span> Delete Labels</button>
            </div>
            <div class="control-group">
                <button id="btn-zoom-in" onclick="zoom(0.5)" class="zoom-btn">${getIcon('zoom-in')}</button>
                <button id="btn-zoom-out" onclick="zoom(-0.5)" class="zoom-btn">${getIcon('zoom-out')}</button>
                <button id="btn-reset-view" onclick="resetView()" class="zoom-btn">${getIcon('maximize')}</button>
            </div>
        `;
            leftPanel.appendChild(toolbar);

            const infobar = document.createElement('div');
            infobar.className = 'lp-infobar';
            infobar.id = 'lp-infobar';
            leftPanel.appendChild(infobar);

            const viewer = document.createElement('div');
            viewer.id = 'image-viewer';
            viewer.className = 'image-viewer';
            const target = document.createElement('div');
            target.id = 'pan-zoom-target';
            viewer.appendChild(target);

            viewer.onwheel = handleWheel;
            viewer.onmousedown = startDrag;
            window.onmouseup = endDrag;
            window.onmousemove = onDrag;
            window.onresize = () => fitImageToViewer();

            leftPanel.appendChild(viewer);

            const rightPanel = document.createElement('div');
            rightPanel.className = 'right-panel';
            const listContainer = document.createElement('div');
            listContainer.id = 'label-list-container';
            listContainer.className = 'list-container';
            rightPanel.appendChild(listContainer);

            container.appendChild(leftPanel);
            container.appendChild(rightPanel);
            app.appendChild(container);
        }

        // --- Logic & Actions ---

        function updateSetting(key, value) {
            state[key] = parseInt(value);
            const valEl = document.getElementById(`val-${key}`);
            if (valEl) {
                valEl.textContent = `${value}${valEl.dataset.unit || ''}`;
            }
            if (key === 'rowMinHeight' || key === 'imageAreaRatio') {
                state.fontSizeCache = {};
            }
            if (state.view === 'labeling') updateLabelingView();
        }

        function handleJsonUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    const json = JSON.parse(ev.target.result);
                    if (!json.labels || !Array.isArray(json.labels)) throw new Error('Invalid JSON structure');
                    state.labelConfig = json.labels;
                    state.errorMsg = '';
                    render();
                } catch (err) {
                    state.errorMsg = "JSON Load Error: " + err.message;
                    render();
                }
            };
            reader.readAsText(file);
        }

        async function selectInputDir() {
            try {
                const handle = await window.showDirectoryPicker({ id: 'input', mode: 'read' });
                state.inputDirHandle = handle;
                state.errorMsg = '';
            } catch (err) {
                if (err.name !== 'AbortError') state.errorMsg = "Folder Selection Error";
            }
            render();
        }

        async function selectOutputDir() {
            try {
                const handle = await window.showDirectoryPicker({ id: 'output', mode: 'readwrite' });
                state.outputDirHandle = handle;
                state.errorMsg = '';
            } catch (err) {
                if (err.name !== 'AbortError') state.errorMsg = "Folder Selection Error";
            }
            render();
        }

        function copySample() {
            navigator.clipboard.writeText(JSON.stringify(SAMPLE_CONFIG, null, 2)).then(() => alert('Copied!'));
        }
        function downloadSample() {
            const blob = new Blob([JSON.stringify(SAMPLE_CONFIG, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'sample_config.json';
            document.body.appendChild(a); a.click();
            document.body.removeChild(a); URL.revokeObjectURL(url);
        }

        // ==========================================
        // Main Logic (Scan & Label)
        // ==========================================

        async function startApp() {
            if (!state.inputDirHandle || !state.labelConfig || !state.outputDirHandle) return;
            state.fontSizeCache = {};
            
            // Initial Scan
            await scanFilesAndStatuses();
            
            if (state.fileList.length === 0) {
                state.errorMsg = "No image files found";
                showLoader(false);
                render();
                return;
            }

            state.view = 'labeling';
            state.currentIndex = 0;
            state.activeLabels = {};
            state.hasExistingJson = false;
            
            // Load first image
            await loadLabelForCurrentFile();
            resetView();
            render();
        }

        async function reloadAll() {
            // Show loader specifically for reload
            showLoader(true, 'Reloading...', 'Scanning files and labels...');
            
            // Allow UI to render loader before processing
            await new Promise(r => setTimeout(r, 10));

            await scanFilesAndStatuses();
            
            // Validate current index
            if (state.currentIndex >= state.fileList.length) {
                state.currentIndex = Math.max(0, state.fileList.length - 1);
            }
            
            if (state.fileList.length > 0) {
                 await loadLabelForCurrentFile();
            }
            
            // Hide loader is handled inside scanFilesAndStatuses, but just in case we override or add logic
            showStatus("Reloaded", false);
            render();
        }

        async function scanFilesAndStatuses() {
            showLoader(true, 'Scanning Files...', 'Getting file lists...');
            
            try {
                const fileList = [];
                const jsonMap = new Map(); // filename -> FileSystemFileHandle

                // 1. Get all JSONs first
                for await (const entry of state.outputDirHandle.values()) {
                    if (entry.kind === 'file' && entry.name.endsWith('.json')) {
                        jsonMap.set(entry.name, entry);
                    }
                }

                // 2. Get all Images
                const images = [];
                for await (const entry of state.inputDirHandle.values()) {
                    if (entry.kind === 'file') {
                        const ext = entry.name.toLowerCase().match(/\.[^.]+$/);
                        if (ext && SUPPORTED_EXTENSIONS.includes(ext[0])) {
                            images.push(entry);
                        }
                    }
                }

                // Sort images
                if (state.randomOrder) {
                    for (let i = images.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [images[i], images[j]] = [images[j], images[i]];
                    }
                } else {
                    images.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));
                }

                // 3. Check status for each image
                // To avoid freezing UI on 5000 files, we process in chunks
                const chunkSize = 50;
                let processed = 0;

                for (let i = 0; i < images.length; i += chunkSize) {
                    const chunk = images.slice(i, i + chunkSize);
                    
                    // Update Loader UI
                    showLoader(true, 'Scanning Status...', `${processed} / ${images.length}`);
                    
                    // Allow UI to breathe
                    await new Promise(r => setTimeout(r, 0));

                    const promises = chunk.map(async (imgHandle) => {
                        const baseName = imgHandle.name.replace(/\.[^.]+$/, "");
                        const jsonName = baseName + ".json";
                        const jsonHandle = jsonMap.get(jsonName);
                        let isDone = false;

                        if (jsonHandle) {
                            try {
                                const file = await jsonHandle.getFile();
                                const text = await file.text();
                                const json = JSON.parse(text);
                                isDone = checkIsFinished(json).isFinished;
                            } catch (e) {
                                // Error reading JSON, assume not done
                            }
                        }

                        return {
                            name: imgHandle.name,
                            handle: imgHandle.handle, // wait, entry itself IS the handle if iterated from values()
                            // correction: entry is the handle.
                            isDone: isDone
                        };
                    });

                    const results = await Promise.all(promises);
                    // Correct handle mapping: chunk items are already handles
                    results.forEach((res, idx) => {
                        res.handle = chunk[idx];
                    });
                    
                    fileList.push(...results);
                    processed += chunk.length;
                }

                state.fileList = fileList;

            } catch (e) {
                console.error(e);
                alert("Error scanning files: " + e.message);
            } finally {
                showLoader(false);
            }
        }

        async function loadLabelForCurrentFile() {
            if (state.fileList.length === 0) return;
            const item = state.fileList[state.currentIndex];
            
            const baseName = item.name.replace(/\.[^.]+$/, "");
            const jsonName = baseName + ".json";
            
            state.activeLabels = {}; // Clear previous
            state.hasExistingJson = false;

            try {
                const handle = await state.outputDirHandle.getFileHandle(jsonName);
                const file = await handle.getFile();
                const text = await file.text();
                state.activeLabels = JSON.parse(text);
                state.hasExistingJson = true;
                
                // Update done status while we are here, just in case
                const status = checkIsFinished(state.activeLabels);
                item.isDone = status.isFinished;
                
            } catch (e) {
                // No JSON exists or error -> empty labels
                state.activeLabels = {};
                state.hasExistingJson = false;
            }
        }

        function goHome() {
            state.view = 'initial';
            render();
        }

        // --- Label Updating ---
        function updateLabel(labelId, value) {
            state.activeLabels[labelId] = value;

            // Check for end_flag_value and nullify subsequent labels
            let startNullifying = false;
            if (state.labelConfig) {
                for (const item of state.labelConfig) {
                    if (startNullifying) {
                        state.activeLabels[item.label_id] = null;
                    } else if (item.label_id === labelId) {
                        // If this label has an end_flag_value and the selected value matches it
                        if (item.end_flag_value !== undefined && item.end_flag_value === value) {
                            startNullifying = true;
                        }
                    }
                }
            }
            
            // Recalculate done status
            const status = checkIsFinished(state.activeLabels);
            const currentItem = state.fileList[state.currentIndex];
            currentItem.isDone = status.isFinished;
            
            render(); // Update UI immediately
            
            triggerSave();

            if ((state.autoNext || state.hideLabeled) && status.isFinished) {
                setTimeout(() => changeImage(1), 300);
            }
        }

        async function triggerSave() {
            const item = state.fileList[state.currentIndex];
            state.pendingSaveFile = item;
            if (!state.isSaving) processSaveQueue();
        }

        async function processSaveQueue() {
            if (!state.pendingSaveFile) {
                state.isSaving = false;
                // DO NOT show "Saved!" here unconditionally, as it might overwrite "Overwrite Denied"
                return;
            }

            state.isSaving = true;
            const item = state.pendingSaveFile;
            state.pendingSaveFile = null;
            showStatus("Saving...", false);

            try {
                const baseName = item.name.replace(/\.[^.]+$/, "");
                const jsonName = baseName + ".json";
                
                let proceed = true;
                if (!state.allowOverwrite) {
                    try {
                        await state.outputDirHandle.getFileHandle(jsonName);
                        // Exists
                        proceed = false; 
                    } catch(e) {
                        // Not exists
                        proceed = true;
                    }
                }

                if (proceed) {
                    const h = await state.outputDirHandle.getFileHandle(jsonName, { create: true });
                    const w = await h.createWritable();

                    // Sort keys based on labelConfig
                    const orderedLabels = {};
                    if (state.labelConfig && Array.isArray(state.labelConfig)) {
                        // 1. Add keys present in config, in config order
                        state.labelConfig.forEach(item => {
                            if (Object.prototype.hasOwnProperty.call(state.activeLabels, item.label_id)) {
                                orderedLabels[item.label_id] = state.activeLabels[item.label_id];
                            }
                        });
                        // 2. (Optional) Add remaining keys that are not in config (to prevent data loss)
                        Object.keys(state.activeLabels).forEach(key => {
                            if (!orderedLabels.hasOwnProperty(key)) {
                                orderedLabels[key] = state.activeLabels[key];
                            }
                        });
                    } else {
                        // Fallback
                        Object.assign(orderedLabels, state.activeLabels);
                    }

                    await w.write(JSON.stringify(orderedLabels, null, 2));
                    await w.close();
                    state.hasExistingJson = true; // Update state after save
                    showStatus("Saved!", false); // Success Message HERE
                } else {
                    showStatus("Overwrite Denied", true); // Failure Message HERE
                }
            } catch(e) {
                console.error(e);
                showStatus("Save Failed", true);
            }
            
            processSaveQueue();
        }

        async function deleteCurrentJson() {
            const item = state.fileList[state.currentIndex];
            if (!confirm(`Delete labels for "${item.name}"?`)) return;

            const baseName = item.name.replace(/\.[^.]+$/, "");
            const jsonName = baseName + ".json";
            
            try {
                await state.outputDirHandle.removeEntry(jsonName);
                state.activeLabels = {};
                item.isDone = false;
                state.hasExistingJson = false;
                render();
                showStatus("Deleted", true);
            } catch(e) {
                showStatus("Error", true);
            }
        }

        function checkIsFinished(labels) {
            if (!state.labelConfig || !labels) return { isFinished: false };
            for (const item of state.labelConfig) {
                const val = labels[item.label_id];
                if (val === undefined) return { isFinished: false };
                if (val !== null && item.end_flag_value !== undefined && val === item.end_flag_value) {
                    return { isFinished: true };
                }
            }
            return { isFinished: true };
        }

        // --- Navigation ---
        
        async function changeImage(delta) {
            forceHideTooltip();
            if (state.isSkipping) return;

            let nextIdx = state.currentIndex + delta;

            if (state.hideLabeled) {
                // Find next file where isDone == false
                state.isSkipping = true;
                
                // Simple search in memory list
                let found = -1;
                let direction = delta > 0 ? 1 : -1;
                let i = state.currentIndex + direction;
                
                while(i >= 0 && i < state.fileList.length) {
                    if (!state.fileList[i].isDone) {
                        found = i;
                        break;
                    }
                    i += direction;
                }
                
                if (found !== -1) {
                    nextIdx = found;
                } else {
                    state.isSkipping = false;
                    showStatus(delta > 0 ? "No more unlabeled" : "No prev unlabeled", true);
                    render(); // to update button states
                    return;
                }
                state.isSkipping = false;
            }

            if (nextIdx >= 0 && nextIdx < state.fileList.length) {
                state.currentIndex = nextIdx;
                // Before rendering, load data
                await loadLabelForCurrentFile();
                resetView();
                render();
            }
        }

        async function toggleHideLabeled() {
            state.hideLabeled = !state.hideLabeled;
            
            const currentItem = state.fileList[state.currentIndex];
            if (state.hideLabeled && currentItem.isDone) {
                state.isSkipping = true;
                // Current is done, move to next available
                // Try forward first
                let found = -1;
                for (let i = state.currentIndex + 1; i < state.fileList.length; i++) {
                    if (!state.fileList[i].isDone) {
                        found = i;
                        break;
                    }
                }
                
                // If not found forward, try backward from start
                if (found === -1) {
                    for (let i = 0; i < state.currentIndex; i++) {
                        if (!state.fileList[i].isDone) {
                            found = i;
                            break;
                        }
                    }
                }
                
                if (found !== -1) {
                    state.currentIndex = found;
                    await loadLabelForCurrentFile();
                    resetView();
                }
                
                state.isSkipping = false;
            }
            render();
        }

        function toggleAutoNext() { state.autoNext = !state.autoNext; render(); }

        let statusTimer;
        function showStatus(msg, isErr) {
            const el = document.getElementById('status-display');
            if (el) {
                el.textContent = msg;
                if (msg === "Read Only") {
                    el.style.color = 'var(--warning)';
                } else {
                    el.style.color = isErr ? '#f87171' : '#34d399';
                }
                
                if (msg === "Saved!" || msg === "Loaded" || msg === "Reloaded" || msg === "Deleted" || msg === "Overwrite Denied") {
                    clearTimeout(statusTimer);
                    statusTimer = setTimeout(() => { if (el) el.textContent = ''; }, 2000);
                }
            }
        }

        // --- Render Helpers ---

        function updateLabelingView() {
            forceHideTooltip();
            
            // Check all done state (visual only)
            // Actually, we can check if visible count is 0
            if (state.hideLabeled) {
                const hasUnlabeled = state.fileList.some(f => !f.isDone);
                if (!hasUnlabeled) {
                    renderAllDoneState();
                    return;
                }
            }

            // --- Normal View ---
            // Re-enable nav buttons (might be disabled by All Done)
            const btnDelete = document.getElementById('btn-delete-json');
            if (btnDelete) btnDelete.disabled = false;
            const btnZoomIn = document.getElementById('btn-zoom-in');
            if (btnZoomIn) btnZoomIn.disabled = false;
            const btnZoomOut = document.getElementById('btn-zoom-out');
            if (btnZoomOut) btnZoomOut.disabled = false;
            const btnReset = document.getElementById('btn-reset-view');
            if (btnReset) btnReset.disabled = false;

            // Check lock status
            const isLocked = !state.allowOverwrite && state.hasExistingJson;
            if (isLocked) {
                showStatus("Read Only", false);
            } else if (document.getElementById('status-display').textContent === "Read Only") {
                showStatus("", false);
            }

            // Layout adjustments
            const leftPanel = document.getElementById('left-panel');
            if (leftPanel) leftPanel.style.width = `${state.imageAreaRatio}%`;

            // Navigation State
            const pageInd = document.getElementById('page-indicator');
            if (pageInd) {
                let dispIdx = state.currentIndex + 1;
                let total = state.fileList.length;
                if (state.hideLabeled) {
                    // Calculate "Page X of Y unlabeled"
                    const unlabeledTotal = state.fileList.filter(f => !f.isDone).length;
                    const unlabeledBefore = state.fileList.slice(0, state.currentIndex + 1).filter(f => !f.isDone).length;
                    
                    if (state.fileList[state.currentIndex].isDone) {
                         // Should not happen usually due to changeImage logic, but handling edge case
                         pageInd.innerHTML = `- <span style="color:#6b7280">/ ${unlabeledTotal}</span>`;
                    } else {
                         pageInd.innerHTML = `${unlabeledBefore} <span style="color:#6b7280">/ ${unlabeledTotal}</span>`;
                    }
                } else {
                    pageInd.innerHTML = `${dispIdx} <span style="color:#6b7280">/ ${total}</span>`;
                }
            }

            const btnPrev = document.getElementById('btn-prev');
            const btnNext = document.getElementById('btn-next');
            if (btnPrev) btnPrev.disabled = state.currentIndex <= 0;
            if (btnNext) btnNext.disabled = state.currentIndex >= state.fileList.length - 1;

            const btnHide = document.getElementById('btn-hide-labeled');
            if (btnHide) btnHide.className = `tool-btn ${state.hideLabeled ? 'active' : ''}`;
            const btnAuto = document.getElementById('btn-auto-next');
            if (btnAuto) btnAuto.className = `tool-btn ${state.autoNext ? 'active-green' : ''}`;

            // Image
            const imgContainer = document.getElementById('pan-zoom-target');
            const infobar = document.getElementById('lp-infobar');
            const currentItem = state.fileList[state.currentIndex];

            if (imgContainer && currentItem) {
                // Check if current image is already loaded correctly
                const currentImg = imgContainer.querySelector('img');
                const loadedName = currentImg ? currentImg.dataset.filename : null;

                if (loadedName !== currentItem.name) {
                    if (infobar) infobar.textContent = currentItem.name;
                    
                    // Clear container FIRST to avoid double images
                    imgContainer.innerHTML = ''; 
                    
                    currentItem.handle.getFile().then(file => {
                        // Check index again to prevent race condition
                        if (state.fileList[state.currentIndex].name !== currentItem.name) return;

                        const img = document.createElement('img');
                        img.src = URL.createObjectURL(file);
                        img.dataset.filename = currentItem.name;
                        img.draggable = false;
                        img.onload = () => {
                            fitImageToViewer();
                            const w = img.naturalWidth;
                            const h = img.naturalHeight;
                            const gcdVal = gcd(w, h);
                            if (infobar) infobar.innerHTML = `${currentItem.name} <span class="dim" style="margin-left:12px;">[ ${w} x ${h} | ${w/gcdVal}:${h/gcdVal} ]</span>`;
                        };
                        
                        // Double check before appending
                        imgContainer.innerHTML = '';
                        imgContainer.appendChild(img);
                    });
                }
            }

            // Right List (Labels)
            updateLabelList();
        }

        function renderAllDoneState() {
            forceHideTooltip();

            // Reset transform state
            state.scale = 1;
            state.position = { x: 0, y: 0 };
            renderTrans();

            const imgContainer = document.getElementById('pan-zoom-target');
            const infobar = document.getElementById('lp-infobar');
            
            if (imgContainer) imgContainer.innerHTML = `
            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; color: #9ca3af; height: 100%;">
                <div style="color: var(--success); margin-bottom: 1rem;">${getIcon('check-circle')}</div>
                <h2 style="font-size: 1.5rem; font-weight: bold; color: white; margin-bottom: 0.5rem;">All Done!</h2>
                <p>All images have been labeled.</p>
                <button onclick="toggleHideLabeled()" style="margin-top: 1.5rem; padding: 0.5rem 1rem; background-color: var(--bg-hover); color: white; border: none; border-radius: 4px; cursor: pointer;">Show All Images</button>
            </div>`;
            
            if (infobar) infobar.textContent = "";
            const pageInd = document.getElementById('page-indicator');
            if (pageInd) pageInd.innerHTML = `<span style="color: var(--success)">Done</span>`;
            
            const btnHide = document.getElementById('btn-hide-labeled');
            if (btnHide) btnHide.className = `tool-btn ${state.hideLabeled ? 'active' : ''}`;

            // Right Panel Message
            const listContainer = document.getElementById('label-list-container');
            if (listContainer) listContainer.innerHTML = `
            <div style="flex: 1; display: flex; align-items: center; justify-content: center; color: #9ca3af;">
                <div style="text-align: center;">
                    <p>No unlabeled images left.</p>
                </div>
            </div>`;

            // Disable Controls
            const btnPrev = document.getElementById('btn-prev');
            if (btnPrev) btnPrev.disabled = true;
            const btnNext = document.getElementById('btn-next');
            if (btnNext) btnNext.disabled = true;
            const btnDelete = document.getElementById('btn-delete-json');
            if (btnDelete) btnDelete.disabled = true;
            const btnZoomIn = document.getElementById('btn-zoom-in');
            if (btnZoomIn) btnZoomIn.disabled = true;
            const btnZoomOut = document.getElementById('btn-zoom-out');
            if (btnZoomOut) btnZoomOut.disabled = true;
            const btnReset = document.getElementById('btn-reset-view');
            if (btnReset) btnReset.disabled = true;
        }

        function updateLabelList() {
            const container = document.getElementById('label-list-container');
            if (!container) return;
            container.innerHTML = '';

            const currentItem = state.fileList[state.currentIndex];
            if (!currentItem) return;

            const labels = state.activeLabels; // Used loaded active labels
            let skipRemaining = false;
            
            const isLocked = !state.allowOverwrite && state.hasExistingJson;

            state.labelConfig.forEach((item, index) => {
                const val = labels[item.label_id];
                const isDisabled = skipRemaining;
                const row = createLabelRow(index, item, val, isDisabled, isLocked);
                container.appendChild(row);

                if (val !== undefined && val !== null && item.end_flag_value !== undefined && val === item.end_flag_value) {
                    skipRemaining = true;
                }
            });
            adjustAllTextSizes();
        }

        function createLabelRow(index, item, val, isDisabled, isLocked) {
            const row = document.createElement('div');
            row.className = `label-row ${isDisabled ? 'disabled' : ''}`;
            row.style.minHeight = `${state.rowMinHeight}px`;

            const nameArea = document.createElement('div');
            nameArea.className = 'row-name';
            nameArea.innerHTML = `<span class="row-idx">${index + 1}.</span><div class="row-name-text"><span class="auto-fit-text" data-cache-key="lbl-name-${index}">${item.label_name}</span></div>`;
            if (item.description) {
                nameArea.classList.add('has-tooltip');
                nameArea.setAttribute('data-tooltip', item.description);
                nameArea.addEventListener('mouseenter', handleMouseEnter);
                nameArea.addEventListener('mouseleave', handleMouseLeave);
            }
            row.appendChild(nameArea);

            const clearArea = document.createElement('div');
            clearArea.className = 'row-clear';

            if (item.mask_option) {
                const maskOpt = item.mask_option;
                const isSelected = val === maskOpt.option_value;
                const btn = document.createElement('button');
                btn.className = `clear-btn ${isSelected ? 'active' : ''}`;
                btn.disabled = isDisabled || isLocked;
                btn.innerHTML = `<span class="auto-fit-text" data-cache-key="lbl-mask-${index}">${maskOpt.option_name || 'Mask'}</span>`;
                if (maskOpt.description) {
                    btn.classList.add('has-tooltip');
                    btn.setAttribute('data-tooltip', maskOpt.description);
                    btn.addEventListener('mouseenter', handleMouseEnter);
                    btn.addEventListener('mouseleave', handleMouseLeave);
                }
                btn.onclick = () => updateLabel(item.label_id, maskOpt.option_value);
                clearArea.appendChild(btn);
            } else {
                const btn = document.createElement('button');
                btn.className = 'clear-btn';
                btn.disabled = true;
                btn.innerText = '-';
                clearArea.appendChild(btn);
            }
            row.appendChild(clearArea);

            const optArea = document.createElement('div');
            optArea.className = 'row-options';
            item.options.forEach((opt, optIdx) => {
                const isSelected = val === opt.option_value;
                const btn = document.createElement('button');
                btn.className = `option-btn ${isSelected ? 'selected' : ''}`;
                btn.disabled = isDisabled || isLocked;
                btn.innerHTML = `<span class="opt-text auto-fit-text" data-cache-key="lbl-opt-${index}-${optIdx}">${opt.option_name}</span>`;
                if (opt.description) {
                    btn.classList.add('has-tooltip');
                    btn.setAttribute('data-tooltip', opt.description);
                    btn.addEventListener('mouseenter', handleMouseEnter);
                    btn.addEventListener('mouseleave', handleMouseLeave);
                }
                btn.onclick = () => updateLabel(item.label_id, opt.option_value);
                optArea.appendChild(btn);
            });
            row.appendChild(optArea);
            return row;
        }

        // --- Common Utils (Zoom/Pan/Cache) ---
        function gcd(a, b) { return b === 0 ? a : gcd(b, a % b); }

        function adjustAllTextSizes() {
            const elements = document.querySelectorAll('.auto-fit-text');
            elements.forEach(el => adjustFontSize(el.parentElement, el));
        }

        function adjustFontSize(container, text) {
            if (!container || !text) return;
            const cacheKey = text.dataset.cacheKey;
            if (cacheKey && state.fontSizeCache[cacheKey]) {
                text.style.fontSize = state.fontSizeCache[cacheKey] + 'px';
                return;
            }
            const style = window.getComputedStyle(container);
            const w = container.clientWidth - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight);
            const h = container.clientHeight - parseFloat(style.paddingTop) - parseFloat(style.paddingBottom);
            if (w <= 0 || h <= 0) return;
            
            let min = 10, max = Math.min(w, h * 0.6, 40), optimal = min;
            text.style.width = 'auto'; text.style.height = 'auto';
            text.style.whiteSpace = 'nowrap'; text.style.lineHeight = '1';
            
            if (max < min) max = min;
            while (min <= max) {
                const mid = Math.floor((min + max) / 2);
                text.style.fontSize = `${mid}px`;
                if (text.scrollWidth <= w * 0.95 && text.scrollHeight <= h * 0.95) {
                    optimal = mid; min = mid + 1;
                } else {
                    max = mid - 1;
                }
            }
            text.style.fontSize = `${optimal}px`;
            text.style.whiteSpace = 'normal'; text.style.lineHeight = '';
            if (cacheKey) state.fontSizeCache[cacheKey] = optimal;
        }

        window.addEventListener('resize', () => {
            state.fontSizeCache = {};
            if (resizeTimer) clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => { if (state.view === 'labeling') { fitImageToViewer(); adjustAllTextSizes(); } }, 100);
        });

        // Tooltip logic
        function positionTooltip(target) {
            const text = target.getAttribute('data-tooltip');
            if (!text) return;
            tooltipEl.textContent = text;
            tooltipEl.classList.add('tooltip--visible');
            const rect = target.getBoundingClientRect();
            const tipRect = tooltipEl.getBoundingClientRect();
            let top = rect.top - tipRect.height - 8;
            let left = rect.left + (rect.width - tipRect.width) / 2;
            if (left < 4) left = 4;
            if (top < 4) top = rect.bottom + 8;
            tooltipEl.style.top = top + 'px'; tooltipEl.style.left = left + 'px';
        }
        function handleMouseEnter(e) {
            const t = e.currentTarget;
            if (hoverTimer) clearTimeout(hoverTimer);
            hoverTimer = setTimeout(() => positionTooltip(t), 1000);
        }
        function handleMouseLeave() {
            if (hoverTimer) clearTimeout(hoverTimer);
            tooltipEl.classList.remove('tooltip--visible');
        }
        function forceHideTooltip() {
            if (hoverTimer) clearTimeout(hoverTimer);
            tooltipEl.classList.remove('tooltip--visible');
        }

        // Viewer logic
        function resetView() { fitImageToViewer(); }
        function fitImageToViewer() {
            const v = document.getElementById('image-viewer');
            const t = document.getElementById('pan-zoom-target');
            if (!v || !t) return;
            const img = t.querySelector('img');
            if (!img || !img.naturalWidth) return;
            state.scale = Math.min(v.clientWidth / img.naturalWidth, v.clientHeight / img.naturalHeight) * 0.95;
            state.position = { x: 0, y: 0 };
            renderTrans();
        }
        function zoom(amt) { state.scale = Math.min(Math.max(0.1, state.scale + amt), 10); renderTrans(); }
        function handleWheel(e) { e.preventDefault(); state.scale = Math.min(Math.max(0.1, state.scale - e.deltaY * 0.001), 10); renderTrans(); }
        function startDrag(e) { if (e.button === 0) { state.isDragging = true; state.dragStart = { x: e.clientX - state.position.x, y: e.clientY - state.position.y }; } }
        function onDrag(e) { if (state.isDragging) { e.preventDefault(); state.position = { x: e.clientX - state.dragStart.x, y: e.clientY - state.dragStart.y }; renderTrans(); } }
        function endDrag() { state.isDragging = false; }
        function renderTrans() { const t = document.getElementById('pan-zoom-target'); if (t) t.style.transform = `translate(${state.position.x}px, ${state.position.y}px) scale(${state.scale})`; }

        render();
    </script>
</body>

</html>